server <- function(input,output,session){
  source("R/SourceAll.R",local=T)

  # fill session_if textOutput with current session$token
  output$session_id <- renderText({
      paste0("Current session: ", session$token)
  })

  # getCurrentVersion(updateDESCRIPTION=T) # Where to Place this ? So it does not always get 'updated'?
  # Can we add this somehow as necassary to every new release?

# Security section ----
  options(shiny.maxRequestSize=20*(1024^2)) # request 20MB

  #### Clean Up
  # create www folder if not present
  if(dir.exists("www")){
    setwd("www")
    # create folder with session tokes as name for all files to be saved inside
    if(!dir.exists(session$token)){
      dir.create(session$token)
      # create REport.md
        write(
            paste0(
            "# cOmicsArt Report (",format(Sys.Date(),'%d/%m/%Y'),")\n\n",
            "This is a report generated by the ",
            "<a href='",
            SERVER,
            "' target='_blank'>cOmicsART</a>",
            " application under version ",
            VERSION,
            ".\n Documentation on the user interface can be found ",
            "<a href='",
            DOCUMENTATION,
            "' target='_blank'>here</a>.\n\n"
            ),
            file=paste0(session$token,"/Report.md")
        )
      print(paste0("Created folder for session: ",session$token))
    } else {
      # remove all files in the folder
      setwd(session$token)
      list <- list.files()
      file.remove(list.files(path="."))
      print("Removed old files for fresh start")
      setwd("..")
    }
    file_path <- paste0("/www/",session$token,"/")
    print(list.files())
    file.remove(
      list.files(path=".") %>%
        setdiff(list.files(path=".", pattern = ".csv")) %>%
        setdiff(list.files(path=".", pattern = ".RDS")) %>%
        setdiff(list.files(path=".", pattern = ".png")) %>%
        setdiff(list.files(path=".", pattern = ".gif"))
    )
    print("Removed old Report files for fresh start")
    setwd("..")
  }
  observe_helpers()
  
  
# Download Report pdf ----
  DownloadReport_server("DownloadTestModule")
  
# Layout upon Start ----
  hideTab(inputId = "tabsetPanel1", target = "Pre-processing")
  hideTab(inputId = "tabsetPanel1", target = "Sample Correlation")
  hideTab(inputId = "tabsetPanel1", target = "Differential Analysis")
  hideTab(inputId = "tabsetPanel1", target = "PCA")
  hideTab(inputId = "tabsetPanel1", target = "Heatmap")
  hideTab(inputId = "tabsetPanel1", target = "Single Gene Visualisations")
  hideTab(inputId = "tabsetPanel1", target = "Enrichment Analysis")
  shinyjs::hideElement(id = "mainPanel_other")
  shinyjs::hideElement(id = "data_summary")
  shinyjs::hideElement(id = "div_sampleCorrelation_main_panel")
  shinyjs::hideElement(id = "PCA_main_panel_div")
  shinyjs::hideElement(id = "Significance_div")
  shinyjs::hideElement(id = "Heatmap_div")
  shinyjs::hideElement(id = "SingleGene_div")
  shinyjs::hideElement(id = "enrichment_div")

# Set Up ad Show user Landing page ----
  # Define the guide
  # Note do this in here to avoid setting a global upon close
  guide_welcome <- Cicerone$
    new(id = "guide",
        opacity = 0.9,
        padding = 10,
        keyboard_control = TRUE)$
    step(
      el = "start_tour",
      title = "Welcome to cOmicsArt!",
      position = "right-center",
      description = HTML("
      <div style='min-width: 300px; min-height: 150px; padding: 10px;'>
        <img src='Logo_cOmicsArt_clear.png' alt='cOmicsArt Logo' style='max-width:90%;'>
        <div style='font-size: 18px; margin-top: 10px;'>
          <p><i class='fas fa-question-circle'></i> Need help? Press the blue button</p>
          <p><i class='fas fa-rocket'></i> Want to start directly? Click 'Next'.</p>
            <div style='font-size: 14px; color: #777; margin-top: 15px;'>
              <p><input type='checkbox' id='set_cookie_checkbox'> Do not show next time (sets a cookie)</p>
            </div>
        </div>
      </div>
    ")
    )$
    step(
      el = "tabsetPanel1",
      title = "Welcome to cOmicsArt!",
      description = "You pressed next - redirection triggered",
    )
  
  # Check if the cookie is present and update the output
  # On page load, check if the cookie exists
  observe({
    shinyjs::runjs("
      if (!checkHasBeenBeforeCookie()) {
        Shiny.setInputValue('first_visit', true);
      } else {
        Shiny.setInputValue('first_visit', false);
      }
    ")
  })

  # If it is the user's first visit, start the guide
  observeEvent(input$first_visit, {
    # TODO: Should we switch to showing data selection by default?
    if (input$first_visit) {
      guide_welcome$init()$start()
    } else {
      showTab(inputId = "tabsetPanel1", target = "Data selection", select = TRUE)
    }
  })
  
  # Delete the cookie if the toggle input is checked
  observeEvent(input$set_cookie, {
      shinyjs::runjs("deleteCookie('hasBeenBefore')")
      showNotification("Cookie 'hasBeenBefore' deleted. Please refresh the page.")
  })

  # Start the tour when the "Start Tour" button is clicked
  observeEvent(input$start_tour, {
    print("Star Tour")
    shinyjs::runjs("document.querySelector('.driver-close-btn').click();")
    guide$init()$start()
  })

  observeEvent(input$guide_cicerone_next, {
    print("Next")
    shinyjs::runjs("document.querySelector('.driver-close-btn').click();")
    showTab(inputId = "tabsetPanel1",target = "Data selection",select = T)
  })

  output$help_tab_info <- renderText({
    HTML(paste0(
    "Please select an image to display within the sidebar(left)<br>",
    "To confirm your selection click the button labelled 'GO show me help!' within the sidebar."
    ))
  })

  output$WelcomePage_ui <- renderUI({
    imageOutput("WelcomePage")
  })

  observeEvent(input$get_help,{
    if(input$ImageSelect == "WelcomePage"){
      output$WelcomePage_ui <- renderUI({
        imageOutput("WelcomePage")
      })
      output$WelcomePage <- renderImage({
        # Path to the image file
        list(
          src = "www/WelcomPage.png",
          contentType = "image/png",
          width = paste0(input$ImageWidth,"%"), # Adjust as needed
          height = input$ImageHeight # Adjust as needed
        )
      }, deleteFile = FALSE) # Set deleteFile to FALSE to keep the image file
      output$help_tab_info <- renderText({
        HTML(
          paste0(
            "As you selected the WelcomePage on the **left**, you can see a screenshot of the WelcomePage below.<br>",
            "If you want to see the full documentation, click ",
            "<a href='https://icb-dcm.github.io/cOmicsArt/' target='_blank'>here</a>",
            ".<br>or click on the link on the top left of the screen 'Go To Documentation'.<br><br>",
            "Within cOmicsArt this box will display information depending on the current tab you are in.<br> A tab represents an analysis."
          )
        )
        }
      )
    } else if(input$ImageSelect == "YouTube Tutorial"){
      output$WelcomePage_ui <- renderUI({
        tags$iframe(
          width = paste0(input$ImageWidth,"%"), # Adjust as needed
          height = input$ImageHeight, # Adjust as needed
          src = "https://www.youtube.com/embed/pTGjtIYQOak",
          frameborder = "0",
          allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
          allowfullscreen = TRUE
        )
      })
    } else if(input$ImageSelect == "nothing selected"){
      output$help_tab_info <- renderText({
        HTML(paste0(
          "You have selected 'nothing selected' - hence there is nothing to show<br>.",
          "Do you want to see something else? Try to select a different Image (Select Image) on the left!<br>",
          "Did you maybe just press the button?"
        ))
      })
      output$WelcomePage_ui <- renderUI({NULL})
    }
  })

  observeEvent(input$NextPanel_tutorial,{
    showTab(inputId = "tabsetPanel1",target = "Data selection",select = T)
  })



# Init res_tmp and par_tmp objects if they do not yet exist ----
  if(!exists("res_tmp")){
    res_tmp <<- list()
    par_tmp <<- list()
  }
  # create an empty list in res/par_tmp[[session$token]]
  res_tmp[[session$token]] <<- list()
  par_tmp[[session$token]] <<- list()
  res_tmp[[session$token]]$passedVI <<- F
  # On session end, remove the list from res/par_tmp
  session$onSessionEnded(function() {
    res_tmp[[session$token]] <<- NULL
    par_tmp[[session$token]] <<- NULL
    # delete the folder with the session token
    if(dir.exists(paste0("www/",session$token))){
      # Remove the directory and its contents
      unlink(paste0("www/",session$token), recursive = TRUE)
      if (!dir.exists(paste0("www/",session$token))) {
        cat("The directory has been successfully removed.\n")
      } else {
        cat("The directory could not be removed.\n")
      }
    }
  })
# Init update Object ----
  # updating is a reative value that counts up whenever data is updated
  # this is used to trigger the update of the servers
  updating <- reactiveValues(count = 0)
## Quit App Button ----
  observeEvent(input$Quit_App,{
    showModal(
      modalDialog(
        tags$h4('You can download the complete report by clicking on the link'),
        footer=tagList(
          a(
            href="Report.html", 
            "Download report", 
            download=NA, 
            target="_blank"
          ),
          actionButton(
            inputId = "Done",
            label = "Done"
          ),
          modalButton('Cancel')
        )
      )
    )
  })
  
  observeEvent(input$Done,{
    removeModal()
    show_toast(
      title = "Good Bye!",
      type = "success",
      position = "top",
      timerProgressBar = FALSE,
      width = "100%"
      )
    session$close()
  })
  
  # Reset file input
  observeEvent(input$clear_FileInput, {
    reset("data_matrix1")
    reset("data_sample_anno1")
    reset("data_row_anno1")
    session$sendCustomMessage(type = "resetValue", message = "data_matrix1")
    session$sendCustomMessage(type = "resetValue", message = "data_sample_anno1")
    session$sendCustomMessage(type = "resetValue", message = "data_row_anno1")
    hideTab(inputId = "tabsetPanel1", target = "Pre-processing")
    hide_tabs()
    output$debug <- renderText({
      "<b>Cleared data, hence there is nothing to upload. Please select your data or use the Testdata</b><br>Make sure to click on  'Upload new data' before proceeding to pre-processing"
    })
  })
  
# Data Upload + checks ----
  print("Data Upload")

## Set reactiveVals ----
  uploaded_from <- reactiveVal(NULL)
  omic_type <- reactiveVal(NULL)

  output$SaveInputAsList <- downloadHandler(
   filename = function() {
     paste0(input$omic_type, "_only_precompiled", " ", Sys.time(), ".RDS") },
    content = function(file){
      # TODO Q: What to save here? only original enough?
      saveRDS(
        object = res_tmp[[session$token]]$data_original,
        file = file
      )
    }
  )
  
  observeEvent(omic_type(),{
    output$AddGeneSymbols_ui <- NULL
    output$AddGeneSymbols_organism_ui <- NULL
    
    if(omic_type() == "Transcriptomics"){
      output$AddGeneSymbols_ui <- renderUI({
        actionButton(
          inputId = "AddGeneSymbols",
          label = "Add Gene Annotation"
        )
      })
      output$AddGeneSymbols_organism_ui <- renderUI({selectInput(
        inputId = "AddGeneSymbols_organism",
        label = "Which Organisms?",
        # choices = listDatasets(useEnsembl(biomart = "genes"))[,"description"],
        choices = c("Mouse genes (GRCm39)", "Human genes (GRCh38.p14)"),
        selected = "Mouse genes (GRCm39)"
      )})
    }
  })

  # Show or hide the gene annotation options based on the button click
  observeEvent(input$geneAnno_toggle_button, {
    shinyjs::toggle(id = "geneAnno_toggle")  # Toggle the div on button click
  })

  observeEvent(input$omic_type_testdata,{
    if(input$omic_type_testdata == "Transcriptomics"){
      output$testdata_help_text <- renderUI({
        HTML(EXAMPLE_RNA_DESCRIPTION)
      })
      }
    })
  
  observeEvent(input$AddGeneSymbols, {
    req(data_input_shiny())
    req(res_tmp[[session$token]]$data_original)
    annotation_result <- detect_annotation(res_tmp[[session$token]]$data_original)
    annotation_name <- annotation_result$AnnoType
    column_name <- annotation_result$AnnoCol

    showModal(modalDialog(
      title = "Gene Annotation",
      HTML(paste0(
        "We tried to find an appropriate annotation and ",
        if (is.null(annotation_name)) {
          
          "found nothing."
        } else {
          paste0("might have found <strong>", annotation_name, "</strong> in <strong>", column_name, "</strong>. Is that correct?")
        }
      )),
      fluidRow(
        column(6, selectInput(
          inputId = "annotation_name",
          label = "Gene Annotation",
          choices = c("entrezgene_id", "ensembl_gene_id", "Symbol"),
          selected = annotation_name
        )),
        column(6, selectInput(
          inputId = "annotation_colname",
          label = "Column Names",
          choices = colnames(rowData(res_tmp[[session$token]]$data_original)),
          selected = column_name
        ))
      ),
      footer = tagList(
        modalButton("Close"),
        actionButton(
          inputId = "do_annotation",
          label = "Do annotation"
        )
      )
    ))
  })

  observeEvent(input$do_annotation, {
    # Added gene annotation if asked for
    if(input$AddGeneSymbols & input[[paste0("omic_type_", uploaded_from())]] == "Transcriptomics") {
      fun_LogIt(
        message = "**DataInput** - Gene Annotation (SYMBOL and gene type) was added"
      )
      fun_LogIt(
        message = paste0("**DataInput** - chosen Organism: ", input$AddGeneSymbols_organism)
      )
      par_tmp[[session$token]]['organism'] <<- input$AddGeneSymbols_organism

      output$debug <- renderText({"<font color=\"#00851d\"><b>Added gene annotation</b></font>"})
      if(par_tmp[[session$token]]['organism'] == "Human genes (GRCh38.p14)"){
        ensembl_slot <- "hsapiens_gene_ensembl"
      }else{
        ensembl_slot <- "mmusculus_gene_ensembl"
      }

      ensembl <- loadedVersion[[ensembl_slot]]$ensmbl
      out <- getBM(
        attributes = c("ensembl_gene_id", "gene_biotype", "external_gene_name", "entrezgene_id"),
        filter = input$annotation_name,
        values = rowData(res_tmp[[session$token]]$data_original)[,input$annotation_colname],
        mart = ensembl
      )
      # Align the rows based on matching annotation
      match_indices <- match(
        rowData(res_tmp[[session$token]]$data_original)[,input$annotation_colname], out[,input$annotation_name]
      )
      matched_out <- out[match_indices, ]

      if (all(is.na(matched_out$ensembl_gene_id))) {
        # Most likely wrong organism used
        output$debug <- renderText({"<font color=\"#ab020a\"><b>You have most likely chosen the wrong organism! No annotation was added</b></font>"})
      } else {
        # Initialize new columns in the rowData with NA
        rowData(res_tmp[[session$token]]$data_original)$ensembl_gene_id <<- NA
        rowData(res_tmp[[session$token]]$data_original)$gene_biotype <<- NA
        rowData(res_tmp[[session$token]]$data_original)$external_gene_name <<- NA
        rowData(res_tmp[[session$token]]$data_original)$entrezgene_id <<- NA

        # Update rowData with matched information
        matched_rows <- !is.na(match_indices)
        rowData(res_tmp[[session$token]]$data_original)$ensembl_gene_id[matched_rows] <<- matched_out$ensembl_gene_id[matched_rows]
        rowData(res_tmp[[session$token]]$data_original)$gene_biotype[matched_rows] <<- matched_out$gene_biotype[matched_rows]
        rowData(res_tmp[[session$token]]$data_original)$external_gene_name[matched_rows] <<- matched_out$external_gene_name[matched_rows]
        rowData(res_tmp[[session$token]]$data_original)$entrezgene_id[matched_rows] <<- matched_out$entrezgene_id[matched_rows]
      }
    }
    
    # edit annotation columns such that if na is present in the row annotation,
    # the na gets replaced by the rowname
    for(i in 1:ncol(rowData(res_tmp[[session$token]]$data))){
      if(any(is.na(rowData(res_tmp[[session$token]]$data)[,i]))){
        rowData(res_tmp[[session$token]]$data)[is.na(rowData(res_tmp[[session$token]]$data)[,i]),i] <<- rownames(res_tmp[[session$token]]$data)[is.na(rowData(res_tmp[[session$token]]$data)[,i])]
      }
    }
    
    for(i in 1:ncol(rowData(res_tmp[[session$token]]$data_original))){
      if(any(is.na(rowData(res_tmp[[session$token]]$data_original)[,i]))){
        rowData(res_tmp[[session$token]]$data_original)[is.na(rowData(res_tmp[[session$token]]$data_original)[,i]),i] <<- rownames(res_tmp[[session$token]]$data_original)[is.na(rowData(res_tmp[[session$token]]$data_original)[,i])]
      }
    }
    
    par_tmp[[session$token]]['addedGeneAnno'] <<- TRUE
    par_tmp[[session$token]]['organism'] <<- input$AddGeneSymbols_organism
    removeModal()
  })

  # Observer to toggle visibility of the download button and helper
  observe({
    if (is.null(uploaded_from())) {
      shinyjs::hide("SaveInputAsRDS")
    }
    req(uploaded_from())
    if (uploaded_from() == "metadata" || uploaded_from() == "file_input") {
      shinyjs::show("SaveInputAsRDS")
    } else {
      shinyjs::hide("SaveInputAsRDS")
    }
  })

  # Observer to toggle visibility of the complete main panel
  observe({
      if (input$refresh1 > 0) {
        req(data_input_shiny() == "DataUploadSuccesful")
        shinyjs::showElement("InfoBox_DataSelection")
        shinyjs::showElement("mainPanel_other")
      } else {
        shinyjs::showElement("InfoBox_DataSelection")
        shinyjs::hideElement("mainPanel_other")
      }
  })
  
## Upload visual inspection ----
  observeEvent(input$inspect_data, {
    showModal(modalDialog(
      title = "Upload Visual Inspection",
      helpText("If you have uploaded your data, you might want to visually check the tables to confirm the correct data format. If you notice irregualarities you will need to correct the input data - this cannot be done in cOmicsArt, See the help on how your data is expected."),
      br(),
      splitLayout(
        style = "border: 1px solid silver:", cellWidths = c("70%", "30%"),
        DT::dataTableOutput("DataMatrix_VI"),
        htmlOutput(outputId = "DataMatrix_VI_Info", container = pre)
      ),
      splitLayout(
        style = "border: 1px solid silver:", cellWidths = c("70%", "30%"),
        DT::dataTableOutput("SampleMatrix_VI"),
        htmlOutput(outputId = "SampleMatrix_VI_Info", container = pre)
      ),
      splitLayout(
        style = "border: 1px solid silver:", cellWidths = c("70%", "30%"),
        DT::dataTableOutput("EntitieMatrix_VI"),
        htmlOutput(outputId = "EntitieMatrix_VI_Info", container = pre)
      ),
      htmlOutput(outputId = "OverallChecks", container = pre),
      easyClose = TRUE,
      footer = tagList(
        actionButton("usingVIdata", "Use the Data"),
        actionButton("CloseVI","Close")
        ),
      size = "l", # large modal
      class = "custom-modal" # custom class for this modal
    ))

    tryCatch({
    if(isTruthy(input$data_preDone)){
      output$DataMatrix_VI_Info <- renderText({
        "Visual Inspection only for primary data, not for precompiled set possible!"
      })
      req(F)
    }
    if(!(isTruthy(input$data_matrix1) &
         (isTruthy(input$data_sample_anno1)|isTruthy(input$metadataInput)) &
         isTruthy(input$data_row_anno1))){
      output$OverallChecks <- renderText(
        "<font color=\"#ab020a\"><b>The Upload has failed completely, or you haven't uploaded anything yet. Need to uploade all three matrices!</b></font>"
        )
    } else {
      flag_csv <- F

      tryCatch(
        expr = {
          Matrix <- read_file(input$data_matrix1$datapath, check.names=T)
          Matrix2 <- read_file(input$data_matrix1$datapath, check.names=F)
          flag_csv <- T
        },
        error = function(e){
          output$OverallChecks <- renderText(
            "<font color=\"#ab020a\"><b>Not a real csv file!</b></font>"
          )
        }
      )

      if(flag_csv == F){
        tryCatch(
          expr = {
            Matrix <- read.table(input$data_matrix1$datapath,check.names = T)
            Matrix2 <- read.table(input$data_matrix1$datapath, check.names = F)
          },
          error = function(e){
            output$OverallChecks <- renderText(
              "<font color=\"#ab020a\"><b>Data Matrix upload failed. Most likely reasons are duplicated row.names. </b></font>"
            )
            Matrix <- readLines(input$data_matrix1$datapath,warn=F)
            Matrix2 <- readLines(input$data_matrix1$datapath,n=10,warn=F) # ensure 'Matrices' are not the same to evoke all related tests to fail
            #put into dataframe to ensure test run smoothly
            Matrix <- data.frame(Matrix)
            Matrix2 <- data.frame(Matrix2)
          }
        )
      }

      tryCatch(
        expr = {
          withCallingHandlers(
            {
              dim(Matrix) # to envoke an error if it is not present
              # (needed sometime as DT sometimes seem to handle errors internally and does not throw an error)
              # not the cleanest but works
              output$DataMatrix_VI <- DT::renderDataTable({
                DT::datatable(data = Matrix)
              })
            },
            warning = function(w) {
              # Optionally handle warnings here
              output$DataMatrix_VI_Info <- renderText({paste0("Warning captured: ",conditionMessage(w))})
            }
          )
        },
        error = function(e) {
          # Handle errors specifically
          output$DataMatrix_VI <- DT::renderDataTable({
            DT::datatable(data = data.frame(Error = "Invalid data for display"))
          })
        }
      )

      output$DataMatrix_VI_Info <- renderText({"Matrix:"})
      if(isTruthy(input$data_sample_anno1)){
        sample_table <- read_file(input$data_sample_anno1$datapath, check.names=T)
      } else if(isTruthy(input$metadataInput)){
        sample_table <- fun_readInSampleTable(input$metadataInput$datapath)
      } else {
        sample_table <- data.frame()
      }

      output$SampleMatrix_VI <- DT::renderDataTable({DT::datatable(data = sample_table)})
      output$SampleMatrix_VI_Info <- renderText({"Sample table:"})

      annotation_rows <- read_file(input$data_row_anno1$datapath, check.names = T)
      output$EntitieMatrix_VI <- DT::renderDataTable({
        DT::datatable(data = annotation_rows)
      })
      output$EntitieMatrix_VI_Info <- renderText({"Entitie table:"})

      ## Do some checking
      snippetYes <- "<font color=\"#00851d\"><b>Yes</b></font>"
      snippetNo <-  "<font color=\"#ab020a\"><b>No</b></font>"
      snippetOrangeNo <- "<font color=\"#FFA500\"><b>No</b></font> But if you use any preprocessing other than `None`, those NAs will be removed"

      check0 <- tryCatch(ifelse(flag_csv,snippetYes,snippetNo),error = function(e) snippetNo)
      check1 <- tryCatch(ifelse(all(rownames(Matrix) == rownames(annotation_rows)),snippetYes,snippetNo),error = function(e) snippetNo)
      check2 <- tryCatch(ifelse(all(colnames(Matrix) == rownames(sample_table)),snippetYes,snippetNo),error = function(e) snippetNo)
      check3 <- tryCatch(ifelse(any(is.na(Matrix) == T),snippetOrangeNo,snippetYes),error = function(e) snippetNo)
      check4 <- tryCatch(ifelse(any(is.na(sample_table) == T),snippetNo,snippetYes),error = function(e) snippetNo)
      check5 <- tryCatch(ifelse(any(is.na(annotation_rows) == T),snippetNo,snippetYes),error = function(e) snippetNo)
      check6 <- tryCatch(ifelse(all(colnames(Matrix2) == colnames(Matrix)),snippetYes,snippetNo),error = function(e) snippetNo)

      check7 <- tryCatch(ifelse(all(sapply(Matrix,is.numeric)),snippetYes,snippetNo),error = function(e) snippetNo)

      if(grepl(snippetYes,check0) &
         grepl(snippetYes,check1) &
         grepl(snippetYes,check2) &
         grepl(snippetYes,check3) &
         grepl(snippetYes,check4) & # not crucial
         # grepl(snippetYes,check5) & # not crucial
         grepl(snippetYes,check6) &
         grepl(snippetYes,check7)){
        res_tmp[[session$token]]$passedVI <<- T
      } else {
        res_tmp[[session$token]]$passedVI <<- F
      }
      res_tmp[[session$token]]$changedDuringVI <<- F
      #TODO ensure that if there are e.g. invalid sample names but als different sample names in data and annotation tables that we catch this

      if(check0 == snippetNo){
        # add help text
        check0 <- paste0(
          snippetNo,
          "\n\tMost likely: You had a xlsx and exported to csv but your excel is in ",
          "german\n\tand/or you use ',' as separators for decimal positions.\n\t",
          "Fix: change your decimal separator in Excel and re-export!"
        )
      }
      if(check5 == snippetNo){
        # Indicate columns with NA
        colsWithNa <- numeric()
        for(i in 1:ncol(annotation_rows)){
           if(any(is.na(annotation_rows[,i]) == T)){
             colsWithNa <- c(colsWithNa,i)
           }
        }
        check5 <- paste0("<font color=\"#FFA500\"><b>No</b></font>",
                         "\n\tFollowing columns are *potentially* problematic: ",
                         "\n\t",paste0(colsWithNa, collapse = ", "),
                         "\n\tNa's will be replaced by rownames per default")
      }
      # ensuring we try to rescue names only if crucial checks pass
      if(check6 == snippetNo & check0 == snippetYes & check7 == snippetYes ){
        # add option to user for automatic column name correction
        showModal(modalDialog(
          title = "Column Name Correction",
          helpText("Some or all of your names are not syntactically valid. Do you want to try to correct them within cOmicsArt?"),
          footer = tagList(
            actionButton("yes_correct_column_names", "Yes"),
            modalButton("No") # Close button by default
          )
        ))
        # Handle "Yes" button click
        observeEvent(input$yes_correct_column_names, {
          removeModal() # Close the modal
          invalidStart_regex <- "^[X0-9_.]"
          space_regex <- "\\s"
          # test if rownames are valid
          if(any(grepl(invalidStart_regex, rownames(Matrix))) | any(grepl(space_regex, rownames(Matrix)))){
            # save orig rownmaes to entite anno
            annotation_rows$original_rownames <- as.character(rownames(Matrix))
            idxTochange <- grepl(invalidStart_regex, rownames(Matrix))
            rownames(Matrix)[idxTochange] <- paste0("entite_", rownames(Matrix)[idxTochange])

            idxTochange_space <- grepl(space_regex, rownames(Matrix))
            rownames(Matrix)[idxTochange_space] <- gsub(space_regex,".",rownames(Matrix)[idxTochange_space])

            allIdx_changes <- sort(unique(c(idxTochange_space,idxTochange)))

            oldnames_matrix <- rownames(Matrix)[allIdx_changes]
            newName_matrix <- rownames(Matrix)[allIdx_changes]
            info_snippet_matrix_row <- paste0("Changes: <br> Matrix: Number of rownames changed: ",length(oldnames_matrix),"<br>",
                                          " e.g. old names: " ,paste0(head(oldnames_matrix,3), collapse = ", "),"<br>",
                                          " changed to: ",paste0(head(newName_matrix,3), collapse = ", "),"<br>")
          }else{
            info_snippet_matrix_row <- ""
          }
          if(any(grepl(invalidStart_regex, colnames(Matrix))) | any(grepl(space_regex, colnames(Matrix)))){
            # save orig colnames to sample anno
            sample_table$original_colnames <- as.character(colnames(Matrix))
            idxTochange <- grepl(invalidStart_regex, colnames(Matrix))
            if(any(grepl("^X", colnames(Matrix)))){
              colnames(Matrix) <- gsub("^X","",colnames(Matrix))
            }
            colnames(Matrix)[idxTochange] <- paste0("sample_", colnames(Matrix)[idxTochange])

            idxTochange_space <- grepl(space_regex, colnames(Matrix))
            colnames(Matrix)[idxTochange_space] <- gsub(space_regex,".",colnames(Matrix)[idxTochange_space])

            allIdx_changes <- sort(unique(c(idxTochange_space,idxTochange)))

            oldnames_matrix <- colnames(Matrix)[allIdx_changes]
            newName_matrix <- colnames(Matrix)[allIdx_changes]
            info_snippet_matrix_column <- paste0("Changes: <br> Matrix: Number of colnames changed: ",length(oldnames_matrix),"<br>",
                     " e.g. old names: " ,paste0(head(oldnames_matrix,3), collapse = ", "),"<br>",
                     " changed to: ",paste0(head(newName_matrix,3), collapse = ", "),"<br>")
          }else{
            info_snippet_matrix_column <- ""
          }
          if(any(grepl(invalidStart_regex, rownames(sample_table))) | any(grepl(space_regex, rownames(sample_table)))){
            idxTochange <- grepl(invalidStart_regex, rownames(sample_table))
            rownames(sample_table)[idxTochange] <- paste0("sample_", rownames(sample_table)[idxTochange])

            idxTochange_space <- grepl(space_regex, rownames(sample_table))
            rownames(sample_table)[idxTochange_space] <- gsub(space_regex,".",rownames(sample_table)[idxTochange_space])

            allIdx_changes <- sort(unique(c(idxTochange_space,idxTochange)))

            oldnames_sample <- rownames(sample_table)[allIdx_changes]
            newName_sample <- rownames(sample_table)[allIdx_changes]
            info_snippet_sample <- paste0("Changes: <br> Sample Table: Number of rownames changed: ",length(oldnames_sample),"<br>",
                     " e.g. old names: " ,paste0(head(oldnames_sample,3), collapse = ", "),"<br>",
                     " changed to: ",paste0(head(newName_sample,3), collapse = ", "),"<br>")
          }else{
            info_snippet_sample <- ""
          }
          if(any(grepl(invalidStart_regex, rownames(annotation_rows))) | any(grepl(space_regex, rownames(annotation_rows)))){
            idxTochange <- grepl(invalidStart_regex, rownames(annotation_rows))
            rownames(annotation_rows)[idxTochange] <- paste0("entite_", rownames(annotation_rows)[idxTochange])

            idxTochange_space <- grepl(space_regex, rownames(annotation_rows))
            rownames(annotation_rows)[idxTochange_space] <- gsub(space_regex,".",rownames(annotation_rows)[idxTochange_space])

            allIdx_changes <- sort(unique(c(idxTochange_space,idxTochange)))

            oldnames_entitie <- rownames(annotation_rows)[allIdx_changes]
            newNames_entitie <- rownames(annotation_rows)[allIdx_changes]
            info_snippet_entitie <- paste0("Changes: <br> Entitie Table: Number of rownames changed: ",length(oldnames_entitie),"<br>",
                     " e.g. oldnames " ,paste0(head(oldnames_entitie,3), collapse = ","),"<br>",
                     " changed to ",paste0(head(newNames_entitie,3), collapse = ","),"<br>")
          }else{
            info_snippet_entitie <- ""
          }

          # TODO if rownames updated put also to report

          # Write the matrices to csv's to allow reupload for later
          write.csv(Matrix, file = paste0("www/",session$token,"/updatedMatrix.csv"), row.names = T)
          write.csv(sample_table, file = paste0("www/",session$token,"/updatedSampleTable.csv"), row.names = T)
          write.csv(annotation_rows, file = paste0("www/",session$token,"/updatedEntitieAnnotation.csv"), row.names = T)
          res_tmp[[session$token]]$changedDuringVI <<- T

          # TODO also set flag to update matrixes upon 'upload new data' within app for this round

          showModal(modalDialog(
            title = "Download Updated Data",
              HTML(paste0("You can download your updated data for later reupload.<br>",
                     info_snippet_matrix_row,"<br>",
                     info_snippet_matrix_column,"<br>",
                     info_snippet_sample,"<br>",
                     info_snippet_entitie
                     )
              ),
            footer = tagList(
              downloadButton(
                outputId = "DownloadUpdatedMatrix",
                label = "Updated Matrix"
              ),
              downloadButton(
                outputId = "DownloadUpdatedSampleTable",
                label = "Updated Sample Table"
              ),
              downloadButton(
                outputId = "DownloadUpdatedEntitieAnnotation",
                label = "Updated Entitie Annotation"
              ),
              actionButton("close_modal_VI", "Close") # Custom close button
            )
          ))


          # Handle data download
          output$DownloadUpdatedMatrix <- downloadHandler(
            filename = function() {
              paste0("updated_dataMatrix", Sys.Date(), ".csv") # Dynamic filename
            },
            content = function(file) {
              write.csv(Matrix, file, row.names = TRUE) # Save the reactive data with row names
            }
          )
          output$DownloadUpdatedSampleTable <- downloadHandler(
            filename = function() {
              paste0("updated_SampleTable", Sys.Date(), ".csv") # Dynamic filename
            },
            content = function(file) {
              write.csv(sample_table, file, row.names = TRUE) # Save the reactive data with row names
            }
          )
          output$DownloadUpdatedEntitieAnnotation <- downloadHandler(
            filename = function() {
              paste0("updated_EntitieAnno", Sys.Date(), ".csv") # Dynamic filename
            },
            content = function(file) {
              write.csv(annotation_rows, file, row.names = TRUE) # Save the reactive data with row names
            }
          )
          observeEvent(input$close_modal_VI, {
            removeModal()  # Close the modal
            # Redo relevant checks
            check1 <- ifelse(all(rownames(Matrix) == rownames(annotation_rows)),snippetYes,snippetNo)
            check2 <- ifelse(all(colnames(Matrix) == rownames(sample_table)),snippetYes,snippetNo)
            check6 <- ifelse(all(colnames(Matrix) == colnames(Matrix)),snippetYes,snippetNo)
            # Add any additional actions you want to perform
            shinyjs::click(id = "inspect_data")
            output$DataMatrix_VI <- DT::renderDataTable({DT::datatable(data = Matrix)})
            output$SampleMatrix_VI <- DT::renderDataTable({DT::datatable(data = sample_table)})
            output$EntitieMatrix_VI <- DT::renderDataTable({
              DT::datatable(data = annotation_rows)
            })
            showNotification("Check if now you pass all tests")
            output$OverallChecks <- renderText({
              paste0(
                "Some overall Checks have been run:\n",
                "<b>REQUIRED</b> (must all be Yes):\n",
                "Data Matrix is a real csv (has ',' as separators:): ",check0,"\n",
                "Data Matrix has only numeric values: ",check7,"\n",
                "Rownames of Matrix are the same as rownames of entitie table ",check1,"\n",
                "Colnames of Matrix are same as rownames of sample table ",check2," \n",
                "Sample IDs have valid names ", check6, "\n\n",
                "<b>OPTIONAL</b> (Yes is optimal but optional; Will result in slight data changes):\n",
                "Matrix has no na (missing values) ",check3,"\n",
                "Sample table no na (missing values) ",check4,"\n",
                "Entitie table no na  (missing values) ",check5,"\n"
              )
            })
            if(grepl(snippetYes,check0) &
               grepl(snippetYes,check1) &
               grepl(snippetYes,check2) &
               grepl(snippetYes,check3) &
               grepl(snippetYes,check4) & # not crucial
              # grepl(snippetYes,check5) & # not crucial
               grepl(snippetYes,check6) &
               grepl(snippetYes,check7)){
              res_tmp[[session$token]]$passedVI <<- T
            } else {
              res_tmp[[session$token]]$passedVI <<- F
            }

          })


          })

        if(check6 == "No"){
          # add help text
          check6 <- paste0(
            snippetNo,
            "\n\tA syntactically valid name consists of letters, numbers,\n\t",
            "the dot or underline characters and starts with a letter.\n\t",
            "Therefore '12345' is invalid, 'ID_12345' is valid.\n\t",
            "Remember to change the Sample ID everywhere (Matrix & Sample Table)."
          )
        }

      }
      if(check7 == snippetNo & check0 == snippetYes){
        # add help text
        propblem_columns <- colnames(Matrix)[!sapply(Matrix,is.numeric)]
        check7 <- paste0(
          snippetNo,
          "\n\tThe data has columns with non-numeric values.",
          "\n\tFollowing ",length(propblem_columns)," columns are potentially problematic: ",
          paste0("\n\t",propblem_columns, collapse = ", ")
        )
      }
      output$OverallChecks <- renderText({
         paste0(
           "Some overall Checks have been run:\n",
           "Data Matrix is a real csv (has ',' as separators:): ",check0,"\n",
           "Data Matrix has only numeric values: ",check7,"\n",
           "Rownames of Matrix are the same as rownames of entitie table ",check1,"\n",
           "Colnames of Matrix are same as rownames of sample table ",check2," \n",
           "Sample IDs have valid names ", check6, "\n",
           "<b>OPTIONAL</b>:\n",
           "Matrix has no na (missing values) ",check3,"\n",
           "Sample table no na (missing values) ",check4,"\n",
           "Entitie table no na  (missing values) ",check5,"\n"
         )
      })
    }
      },
    error = function(e){
      show_toast(
        title = "Data did not passed visual inspection. Please refer to the Documentation to readjust and then reupload your data accordinlgy.",
        type = "error",
        position = "top",
        timerProgressBar = FALSE,
        width = "100%"
      )
    })
  })

  # Visual Inspection ends here

  observeEvent(input$usingVIdata,{
    if(res_tmp[[session$token]]$passedVI){
      uploaded_from("VI_data")
      removeModal()
      # take specification from file_input as only here VI applicable
      par_tmp[[session$token]]['omic_type'] <<- input[[paste0("omic_type_file_input")]]
      omic_type(input[[paste0("omic_type_file_input")]])
      shinyjs::click("refresh1")
    }else{
      show_toast(
        title = "Data did not passed visual inspection. Data is not used and needs adjustments before reuploading and usage within cOmicsArt!",
        type = "error",
        position = "top",
        timerProgressBar = FALSE,
        width = "100%"
      )
    }

  })
  observeEvent(input$CloseVI,{
    removeModal()
  })


  observeEvent(input$refresh_file_input, {
    uploaded_from("file_input")
    shinyjs::click("refresh1")
  })

  observeEvent(input$refresh_precompiled, {
    uploaded_from("precompiled")
    shinyjs::click("refresh1")
  })

  observeEvent(input$refresh_metadata, {
    uploaded_from("metadata")
    shinyjs::click("refresh1")
  })

  observeEvent(input$EasyTestForUser,{
    uploaded_from("testdata")
    shinyjs::click("refresh1")
  })
  
  
## Do Upload ----
  observeEvent(input$refresh1,{
    req(data_input_shiny())
    par_tmp[[session$token]]['addedGeneAnno'] <<- FALSE
    fun_LogIt(message = "## Data Selection {.tabset .tabset-fade}")
    fun_LogIt(message = "### Info")
    fun_LogIt(
      message = paste0("**DataInput** - Uploaded Omic Type: ", par_tmp[[session$token]]['omic_type'])
    )
    if(!(
      # Is Precompiled data used?
      (isTruthy(input$data_preDone) & uploaded_from() == "precompiled") |
      # Is File Input used?
      (isTruthy(input$data_matrix1) &
        isTruthy(input$data_sample_anno1) &
        isTruthy(input$data_row_anno1) &
        uploaded_from() == "file_input"
      ) |
      # Is Metadata used?
      (isTruthy(input$data_matrix_metadata) &
        isTruthy(input$metadataInput) &
        isTruthy(input$data_row_anno_metadata) &
        uploaded_from() == "file_input"
      ) |
      uploaded_from() == "VI_data" |
      # Is Test Data used?
      uploaded_from() == "testdata"
    )){
      output$debug <- renderText("The Upload has failed, or you haven't uploaded anything yet")
    } else if (uploaded_from() == "testdata"){
      show_toast(
        title = paste(par_tmp[[session$token]]['omic_type'],"Example Upload"),
        text = paste(par_tmp[[session$token]]['omic_type'],"- Example upload was successful"),
        position = "top",
        timer = 1500,
        timerProgressBar = T
      )
      output$debug <- renderText({"The Test Data Set was used"})
    } else {
      show_toast(
        title = paste(par_tmp[[session$token]]['omic_type'],"Data Upload"),
        text = paste(par_tmp[[session$token]]['omic_type'],"- data upload was successful"),
        position = "top",
        timer = 1500,
        timerProgressBar = T
      )
      output$debug <- renderText({
        paste0(
        "<font color=\"#00851d\"><b>Upload successful</b></font>",
        "<br>",ifelse(uploaded_from()=="file_input", paste0("The following data files are uploaded to cOmicsArt:",
                                                           "<br>Data Matrix: ", input$data_matrix1$name,
                                                           "<br>Sample Annotation: ", input$data_sample_anno1$name,
                                                           "<br>Entitie Annotation: ", input$data_row_anno1$name),""),
        "<br>",ifelse(uploaded_from()=="metadata", paste0("The following data files are uploaded to cOmicsArt:",
                                                           "<br>Data Matrix: ", input$data_matrix_metadata$name,
                                                           "<br>Sample Annotation: ", input$metadataInput$name,
                                                           "<br>Entitie Annotation: ", input$data_row_anno_metadata$name),""),
        "<br>",ifelse(uploaded_from()=="precompiled", paste0("The following data files are uploaded to cOmicsArt:",
                                                           "<br>Precompiled Data: ", input$data_preDone$name),"")
        )
      })
      if(isTruthy(input$data_preDone)){
        # precomplied set used
        fun_LogIt(message = paste0(
          "**DataInput** - The used data was precompiled. Filename: \n\t",
          input$data_preDone$name
        ))
      } else if(uploaded_from() == "VI_data"){
        fun_LogIt(message = paste0(
          "**DataInput** - The used data was uploaded for visual inspection and changed within.")
        )
        }else {
        fun_LogIt(message = paste0(
          "The following data was used: \n\t",
          input$data_matrix1$name,"\n\t",
          input$data_sample_anno1$name,"\n\t",
          input$data_row_anno1$name
        ))

        fun_LogIt(message = paste0(
          "**DataInput** - The raw data dimensions are: ",
          paste0(dim(res_tmp[[session$token]]$data_original),collapse = ", ")
        ))
        
      }
      showTab(inputId = "tabsetPanel1", target = "Pre-processing")

    }
  })

## create data object ----
  data_input_shiny <- eventReactive(input$refresh1,{
    if(is.null(unlist(par_tmp[[session$token]]['omic_type']))){
      par_tmp[[session$token]]['omic_type'] <<- input[[paste0("omic_type_", uploaded_from())]]
      omic_type(input[[paste0("omic_type_", uploaded_from())]])
    }
    # Add check if the data upload fails due to no supply of files
    if(!((isTruthy(input$data_preDone) & uploaded_from() == "precompiled") |
      # Is File Input used?
      (isTruthy(input$data_matrix1) &
        isTruthy(input$data_sample_anno1) &
        isTruthy(input$data_row_anno1) &
        uploaded_from() == "file_input"
      ) |
      # Is Metadata used?
      (isTruthy(input$data_matrix_metadata) &
        isTruthy(input$metadataInput) &
        isTruthy(input$data_row_anno_metadata) &
        uploaded_from() == "file_input"
      ) |
      # Is Test Data used?
      (uploaded_from() == "testdata") |
      (uploaded_from() == "VI_data")
    )){
      # if it is not evaluted to TRUE
      output$debug <- renderText({
        "<font color=\"#FF0000\"><b>Upload failed, please check your input - Did you specify all files?.</b></font>"
      })
      req(FALSE)
    }
    # initialize empty data_input object
    data_input <- list()
    # upload depending on where the button was clicked
    if(uploaded_from() == "file_input"){
      tryCatch({
        data_input <- list(
          Matrix = read_file(input$data_matrix1$datapath, check.names=T),
          sample_table = read_file(input$data_sample_anno1$datapath, check.names=T),
          annotation_rows = read_file(input$data_row_anno1$datapath, check.names=T)
        )
        # check if only 1 col in anno row,
        # add dummy col to ensure R does not turn it into a vector
        if(ncol(data_input$annotation_rows) < 2){
          data_input$annotation_rows$origRownames <- rownames(data_input$annotation_rows)
        }

      },error = function(e){
        output$debug <- renderText({
          "<font color=\"#FF0000\"><b>Upload failed, please check your input.</b></font>"
        })
        reset('data_matrix1')
        reset('data_sample_anno1')
        reset('data_row_anno1')
        session$sendCustomMessage(type = "resetValue", message = "data_matrix1")
        session$sendCustomMessage(type = "resetValue", message = "data_sample_anno1")
        session$sendCustomMessage(type = "resetValue", message = "data_row_anno1")
        return(NULL)
      })
    } else if(uploaded_from() == "metadata"){
      tmp_sampleTable <- fun_readInSampleTable(input$metadataInput$datapath)
      test_data_upload <- function(){
        tryCatch({
          data_input <- list(
            type = as.character(input[[paste0("omic_type_", uploaded_from())]]),
            Matrix = read_file(
              input$data_matrix1$datapath, check.names=T
              )[,rownames(tmp_sampleTable)],
            sample_table = tmp_sampleTable,
            annotation_rows = read_file(input$data_row_anno1$datapath, check.names=T)
            )
          return(data_input)
        },
        error = function(){
          print("Error! Names From SampleTable and Matrix do not fit")
          output$debug <- renderText({
            "<font color=\"#FF0000\"><b>Your Sample Names from the Metadata Sheet and from your Matrix do not match!! Data cannot be loaded</b></font>"
          })
          reset('metadataInput')
          session$sendCustomMessage(type = "resetValue", message = "metadataInput")
          return(NULL)
        })
      }
      data_input <- test_data_upload()

      
    } else if(uploaded_from() == "precompiled"){
      # Expand to work with any SummarizedExperiment object
      # (also works with an 'old' pre-compiled object generated by the app)
      uploadedFile <- readRDS(file = input$data_preDone$datapath)
      # Check if the object is a SummarizedExperiment
      if (is(uploadedFile, "SummarizedExperiment")) {
       # a SE object - only esnure that naming of the obeject list fits or re-do
        data_input[[paste0(omic_type(),"_SumExp")]] <- uploadedFile
        count_matrix <- assay(data_input[[paste0(omic_type(),"_SumExp")]])
        if (any(is.na(count_matrix))){
          output$debug <- renderText({
            "<font color=\"#FF0000\"><b>The assay data contains missing values, those will be removed.</b></font>"
          })
        }else{
          if (any(count_matrix < 0)) {
            output$debug <- renderText({
              "<font color=\"#FF0000\"><b>The assay data contains negative values, which are invalid for some pre-processing procedures.</b></font>"
            })
          }
          if (!all(count_matrix == round(count_matrix))) {
            output$debug <- renderText({
              "<font color=\"#FF0000\"><b>The assay data contains non-integer values, which is invalid for DESeq2 pre-processing procedure.</b></font>"
            })
          }
        }
        } else if(is.list(uploadedFile) & any(sapply(uploadedFile, function(x) is(x, "SummarizedExperiment")))){
        # get the sum exp from the list
          getIdxOfSumExp <- sapply(uploadedFile, function(x) is(x, "SummarizedExperiment"))
          if(length(which(getIdxOfSumExp)) > 1){
          output$debug <- renderText({
            "<font color=\"#FF0000\"><b>Upload failed. The provided input contains more than one Summarized Experiment object. Please only provide one</b></font>"
            return(NULL)
            })
          }else{
            data_input[[paste0(omic_type(),"_SumExp")]] <- uploadedFile[[which(getIdxOfSumExp)]]
            count_matrix <- assay(data_input[[paste0(omic_type(),"_SumExp")]])
            if (any(is.na(count_matrix))){
              output$debug <- renderText({
                "<font color=\"#FF0000\"><b>The assay data contains missing values, those will be removed.</b></font>"
              })
            }else{
              if (any(count_matrix < 0)) {
                output$debug <- renderText({
                  "<font color=\"#FF0000\"><b>The assay data contains negative values, which are invalid for some pre-processing procedures.</b></font>"
                })
              }
              if (!all(count_matrix == round(count_matrix))) {
                output$debug <- renderText({
                  "<font color=\"#FF0000\"><b>The assay data contains non-integer values, which is invalid for DESeq2 pre-processing procedure.</b></font>"
                })
              }
            }

            }
        }else{
        # not a SE object
        output$debug <- renderText({
          "<font color=\"#FF0000\"><b>Upload failed. Is the provided input Summarized Experiment object?</b></font>"
        })
        return(NULL)
      }
      
      
    } else if(uploaded_from() == "testdata"){
      data_input <- readRDS(
        file = "www/Transcriptomics_only_precompiled-LS.RDS"
      )
      fun_LogIt(
        message = paste0("<font color=\"#FF0000\"><b>**Attention** - Test Data set used</b></font>")
      )
    } else if(uploaded_from() == "VI_data"){
      if(res_tmp[[session$token]]$changedDuringVI){
        data_input <- list(
          Matrix = read_file(paste0("www/",session$token,"/updatedMatrix.csv"), check.names=T),
          sample_table = read_file(paste0("www/",session$token,"/updatedSampleTable.csv"), check.names=T),
          annotation_rows = read_file(paste0("www/",session$token,"/updatedEntitieAnnotation.csv"), check.names=T)
        )
      }else{
        data_input <- list(
          Matrix = read_file(input$data_matrix1$datapath, check.names=T),
          sample_table = read_file(input$data_sample_anno1$datapath, check.names=T),
          annotation_rows = read_file(input$data_row_anno1$datapath, check.names=T)
        )
        # check if only 1 col in anno row,
        # add dummy col to ensure R does not turn it into a vector
        if(ncol(data_input$annotation_rows) < 2){
          data_input$annotation_rows$origRownames <- rownames(data_input$annotation_rows)
        }
      }
    } else {
      output$debug <- renderText({
        "<font color=\"#FF0000\"><b>Upload failed, please check your input.</b></font>"
      })
      return(NULL)
    }

    if(!any(class(data_input) == "SummarizedExperiment") & !any(grepl('SumExp',names(data_input))) ){
      summarized_experiment <- tryCatch(
        expr = {
          ## Lets Make a SummarizedExperiment Object for reproducibility and further usage
          sum_exp <- SummarizedExperiment(
            assays  = list(raw = data_input$Matrix),
            rowData = data_input$annotation_rows[rownames(data_input$Matrix),,drop=F],
            colData = data_input$sample_table
          )
          sum_exp
        },
        error = function(e){
          print("Error! Uploading via file input failed")
          custom_error <- list()
          custom_error[["message"]] <- "Uploading via file input failed"
          error_modal(custom_error)
          output$debug <- renderText({
            "<font color=\"#FF0000\"><b>Upload failed</b></font>: <br>The uploaded files could not be put into a SummarizedExperiment.<br>Try the 'Inspect data' button for potential errors."
          })
          NULL
        }
      )
      if(is.null(summarized_experiment)){
        return(NULL)
      } else {
        #data_input[[paste0(input[[paste0("omic_type_", uploaded_from())]],"_SumExp")]] <- summarized_experiment
        data_input[[paste0(omic_type(),"_SumExp")]] <- summarized_experiment
      }
      #TODO make the copy and tab show process dependent if we get here a results object or 'simple' rds
    }
    # TODO SumExp only needed hence more restructuring needed

    res_tmp[[session$token]][['data_original']] <<- data_input[[paste0(omic_type(),"_SumExp")]]
    # Make a copy, to leave original data untouched
    res_tmp[[session$token]][['data']] <<- res_tmp[[session$token]]$data_original
    # Count up updating
    updating$count <- updating$count + 1
    # Check if the data is a SummarizedExperiment
    colData(res_tmp[[session$token]]$data) <- DataFrame(
      as.data.frame(colData(res_tmp[[session$token]]$data)) %>%
      purrr::keep(~length(unique(.x)) != 1)
    )
    print(paste0(
      "Number. of anno options sample_table lost: ",
      ncol(res_tmp[[session$token]]$data_original) - ncol(res_tmp[[session$token]]$data)
    ))

    rowData(res_tmp[[session$token]]$data) <- DataFrame(
      as.data.frame(rowData(res_tmp[[session$token]]$data)) %>%
        purrr::keep(~length(unique(.x)) != 1)
    )
    
    # edit annotation columns such that if na is present in the row annotation,
    # the na gets replaced by the rowname
    for(i in 1:ncol(rowData(res_tmp[[session$token]]$data))){
      if(any(is.na(rowData(res_tmp[[session$token]]$data)[,i]))){
        rowData(res_tmp[[session$token]]$data)[is.na(rowData(res_tmp[[session$token]]$data)[,i]),i] <<- rownames(res_tmp[[session$token]]$data)[is.na(rowData(res_tmp[[session$token]]$data)[,i])]
      }
    }
    
    for(i in 1:ncol(rowData(res_tmp[[session$token]]$data_original))){
      if(any(is.na(rowData(res_tmp[[session$token]]$data_original)[,i]))){
        rowData(res_tmp[[session$token]]$data_original)[is.na(rowData(res_tmp[[session$token]]$data_original)[,i]),i] <<- rownames(res_tmp[[session$token]]$data_original)[is.na(rowData(res_tmp[[session$token]]$data_original)[,i])]
      }
    }
    
    print(paste0(
      "Number. of anno options annotation_rows lost: ",
      nrow(res_tmp[[session$token]]$data_original) - nrow(res_tmp[[session$token]]$data)
    ))
    return("DataUploadSuccesful")
  })
  #data_input_shiny = is the res object now which is global => not needed ?!
  print("Data Input done")
  
# Data Selection  ----
## Ui Section ----
  observe({
    req(data_input_shiny())
    isTruthy(res_tmp[[session$token]]$data)
    # Row
    output$providedRowAnnotationTypes_ui <- renderUI({shinyWidgets::virtualSelectInput(
      inputId = "providedRowAnnotationTypes",
      label = "Which annotation type do you want to select on?",
      choices = c(colnames(rowData(res_tmp[[session$token]]$data_original))),
      multiple = F,
      search = T,
      showSelectedOptionsFirst = T
    )})
    output$row_selection_ui <- renderUI({
      req(input$providedRowAnnotationTypes)
      if(is.numeric(
        rowData(res_tmp[[session$token]]$data_original)[,input$providedRowAnnotationTypes])
      ){
        selectInput(
          inputId = "row_selection",
          label = "Which entities to use? (Your input category is numeric, selection is currently only supported for categorical data!)",
          choices = c("all"),
          selected = "all",
          multiple = T
        )
      } else {
        shinyWidgets::virtualSelectInput(
          inputId = "row_selection",
          label = "Which entities to use? (Will be the union if multiple selected)",
          choices = c("High Values+IQR","all",unique(unlist(strsplit(rowData(res_tmp[[session$token]]$data_original)[,input$providedRowAnnotationTypes],"\\|")))),
          selected = "all",
          multiple = T,
          search = T,
          showSelectedOptionsFirst = T
        )
      }
    })
    output$propensityChoiceUser_ui <- renderUI({
      req(data_input_shiny())
      req(any(input$row_selection == "High Values+IQR"))
      numericInput(
        inputId = "propensityChoiceUser",
        label = "Specifcy the propensity for variablity & Expr",
        value = 0.85,
        min = 0,
        max = 1
      )
    })
    # Column /Sample
    output$providedSampleAnnotationTypes_ui <- renderUI({
      req(data_input_shiny())
      selectInput(
        inputId = "providedSampleAnnotationTypes",
        label = "Which annotation type do you want to select on?",
        choices = c(colnames(colData(res_tmp[[session$token]]$data_original))),
        selected = c(colnames(colData(res_tmp[[session$token]]$data_original)))[1],
        multiple = F
      )
    })
    output$sample_selection_ui <- renderUI({
      req(data_input_shiny(),isTruthy(input$providedSampleAnnotationTypes))
      selectInput(
        inputId = "sample_selection",
        label = "Which entities to use? (Will be the union if multiple selected)",
        choices = c(
          "all",
          unique(colData(res_tmp[[session$token]]$data_original)[,input$providedSampleAnnotationTypes])
        ),
        selected = "all",
        multiple = T
      )
    })
  })
  
## Log Selection ----
  observeEvent(c(input$NextPanel, input$use_full_data),{
    # Do actual selection before logging
    print(selectedData())
    # add row and col selection options
    fun_LogIt(message = "**DataSelection** - The following selection was conducted:")
    print(length(input$sample_selection))
    fun_LogIt(message = paste0(
      "**DataSelection** - Samples:\n\t DataSelection - based on: ",
      input$providedSampleAnnotationTypes,": ",
      paste(input$sample_selection,collapse = ", ")
    ))
    fun_LogIt(message = paste0(
      "**DataSelection** - Entities:\n\t DataSelection - based on: ",
      input$providedRowAnnotationTypes,
      ": ",paste(input$row_selection,collapse = ", ")
    ))
    if(!is.null(input$propensityChoiceUser)){
      # also record IQR if this + other selection was selected
      fun_LogIt(message = paste0(
        "**DataSelection** - IQR treshold: ",
        input$propensityChoiceUser
      ))
    }
    
    fun_LogIt(message = "### Publication Snippet")
    fun_LogIt(message = snippet_dataInput(data=res_tmp[[session$token]],
                                          params=par_tmp[[session$token]]))
    fun_LogIt(message = "<br>")
    showTab(inputId = "tabsetPanel1",target = "Pre-processing",select = T)
  })
  
  ## Do Selection ----  
  selectedData <- reactive({
    req(data_input_shiny())
    row_selection <- input$row_selection %||% "all"
    sample_selection <- input$sample_selection %||% "all"
    sample_type <- input$providedSampleAnnotationTypes %||% c(colnames(colData(res_tmp[[session$token]]$data_original)))[1]
    row_type <- input$providedRowAnnotationTypes %||% c(colnames(rowData(res_tmp[[session$token]]$data_original)))[1]
    propensity <- input$propensityChoiceUser %||% 1
    par_tmp[[session$token]][["selected_rows"]] <<- row_selection
    par_tmp[[session$token]][["selected_samples"]] <<- sample_selection
    par_tmp[[session$token]][["row_type"]] <<- row_type
    par_tmp[[session$token]][["sample_type"]] <<- sample_type
    par_tmp[[session$token]]['propensity'] <<- propensity
    print("Alright do Row selection")
    # Data set selection
    res_select <- select_data(
        data = res_tmp[[session$token]]$data_original,
        selected_rows = row_selection,
        selected_samples = sample_selection,
        row_type = row_type,
        sample_type = sample_type,
        propensity = propensity
    )
    res_tmp[[session$token]]$data <<- res_select$data
    par_tmp[[session$token]][['samples_selected']] <<- res_select$samples_selected
    par_tmp[[session$token]][['entities_selected']] <<- res_select$rows_selected
    return("Selection Success")
  })
  
# Pre-processing after Selection ----
# Set Selected Data as Head to allow reiteration of pre-processing

## UI section ----
  # Update the batch effect UI based on the available columns
  output$batch_effect_ui <- renderUI({
    req(data_input_shiny())
    column_names <- colnames(colData(res_tmp[[session$token]]$data_original))
    filtered_column_names <- column_names[sapply(column_names, function(col) {
      length(unique(colData(res_tmp[[session$token]]$data_original)[[col]])) < nrow(colData(res_tmp[[session$token]]$data_original))
    })]
    if (input$PreProcessing_Procedure == "vst_DESeq") {
      filtered_column_names <- filtered_column_names[!filtered_column_names %in% c(input$DESeq_formula_sub)]
    }
    selectInput(
      inputId = "BatchEffect_Column",
      label = "[optional] Select Batch Effect Column",
      choices = c("NULL", filtered_column_names),
      selected = "NULL"
    )
  })
  output$DESeq_formula_sub_ui <- renderUI({
    req(data_input_shiny())
    req(input$PreProcessing_Procedure == "vst_DESeq")
    selectInput(
      inputId = "DESeq_formula_sub",
      label = paste0(
        "Choose factors to account for ",
        "(App might crash if your factor has only 1 sample per level)"
      ),
      choices = c(colnames(colData(res_tmp[[session$token]]$data))),
      multiple = T,
      selected = "condition"
    ) %>% helper(type = "markdown", content = "PreProcessing_DESeq")
  })

  output$Statisitcs_Data <- renderText({
    "Press 'Get-Preprocessing' to start!"
  })

## Preprocessing ----
  selectedData_processed <- eventReactive(input$Do_preprocessing,{
    # only enter this when you actually click data
    req(input$Do_preprocessing > 0)
    shinyjs::showElement(id = "data_summary")
    waiter <- Waiter$new(
      html = LOADING_SCREEN,
      color = "#3897F147",
      hide_on_render = FALSE

    )
    waiter$show()
    print(selectedData())
    # ---- Value Assignment and Parameter Saving for later use ----
    preprocessing_procedure <- input$PreProcessing_Procedure
    batch_column <- input$BatchEffect_Column %||% "NULL"
    omic_type <- par_tmp[[session$token]]$omic_type
    deseq_factors <- input$DESeq_formula_sub %||% NULL
    rows_selected <- par_tmp[[session$token]][['entities_selected']]
    samples_selected <- par_tmp[[session$token]][['samples_selected']]
    # reset data to the selection that was done
    data <- res_tmp[[session$token]]$data_original[rows_selected,samples_selected]
    data_selected <- data  # needed for batch correction with DESeq
    par_tmp[[session$token]]['BatchColumn'] <<- batch_column
    # preprocessing
    print(paste0("Do chosen Preprocessing:",preprocessing_procedure))
    
    # Check for DESeq option if more than 100 genes avail as it is for omics!
    tryCatch({
      preprocess_res <<- preprocessing(
        data = data,
        omic_type = omic_type,
        preprocessing_procedure = preprocessing_procedure,
        deseq_factors = deseq_factors
      )
      par_tmp[[session$token]]['preprocessing_procedure'] <<- preprocessing_procedure
      data <- preprocess_res$data
      if(preprocessing_procedure == "vst_DESeq"){
        res_tmp[[session$token]]$DESeq_obj <<- preprocess_res$DESeq_obj
        par_tmp[[session$token]]["deseq_formula"] <<- paste("~", paste(deseq_factors, collapse = " + "))
        par_tmp[[session$token]]["deseq_factors"] <<- deseq_factors
      }
    }, error = function(e){
      error_modal(e)
      output$Statisitcs_Data <- renderText({ERROR_PREPROC})
      hide_tabs()
      waiter$hide()
      req(FALSE)
    })

    # Checks and Warnings
    addWarning <- create_warning_preproc(data, preprocessing_procedure)
    data <- data[complete.cases(assay(data)),]

    # Batch correction after preprocessing
    tryCatch({
      res_batch <- batch_correction(
        data = if(preprocessing_procedure == "vst_DESeq"){data_selected}else{data},
        preprocessing_procedure = preprocessing_procedure,
        batch_column = batch_column,
        deseq_factors = deseq_factors,
        omic_type = omic_type
      )
      res_tmp[[session$token]]$data_batch_corrected <<- res_batch$data
      if(preprocessing_procedure == "vst_DESeq"){
          res_tmp[[session$token]]$DESeq_obj_batch_corrected <<- res_batch$DESeq_obj
          par_tmp[[session$token]]["DESeq_formula_batch"] <<- paste(
            "~", paste(c(deseq_factors, batch_column), collapse = " + ")
          )
      }
    }, error = function(e){
      error_modal(
        e, additional_text = ifelse(
          preprocessing_procedure == "vst_DESeq", ERROR_BATCH_DESEQ, ERROR_BATCH_CORR
        )
      )
      output$Statisitcs_Data <- renderText({ERROR_PREPROC})
      hide_tabs()
      waiter$hide()
      req(FALSE)
    })
    # assign res_tmp finally
    res_tmp[[session$token]]$data <<- data

    show_tabs()
    
    # Count up updating
    updating$count <- updating$count + 1

    output$Statisitcs_Data <- renderText({
      shinyjs::click("SignificanceAnalysis-refreshUI",asis = T)
      shinyjs::click("single_gene_visualisation-refreshUI",asis = T)
      shinyjs::click("EnrichmentAnalysis-refreshUI",asis = T)
      shinyjs::click("Heatmap-refreshUI",asis = T)
      shinyjs::click("PCA-refreshUI",asis = T)
      shinyjs::click("sample_correlation-refreshUI",asis = T)
      paste0(
        "The data has the dimensions of: ",
        paste0(dim(data),collapse = ", "),
        "<br","If logX was chosen, in case of 0's present logX(data+1) is done",
        "<br","See help for details",
        "<br>",ifelse(any(as.data.frame(assay(data)) < 0),"Be aware that processed data has negative values, hence no log fold changes can be calculated",""))
    })
    # set the warning as toast
    show_toast(
      title = "Attention",
      text = HTML(addWarning),
      position = "top",
      timer = 2500,
      timerProgressBar = T
    )

    output$raw_violin_plot <- renderPlot({
      violin_plot(res_tmp[[session$token]]$data_original[par_tmp[[session$token]][['entities_selected']],par_tmp[[session$token]][['samples_selected']]],
                  violin_color = input$violin_color)
      })
    output$preprocessed_violin_plot <- renderPlot({
      violin_plot(res_tmp[[session$token]]$data,
                  violin_color = input$violin_color)
      })
    par_tmp[[session$token]]['violin_color'] <<- input$violin_color
    waiter$hide()
    return("Pre-Processing successfully")
  })
  
## Log preprocessing ----
  observeEvent(input$Do_preprocessing,{
    print(selectedData_processed())
    if(par_tmp[[session$token]]$omic_type == "Transcriptomics"){
      tmp_logMessage <- "Remove anything which row Count <= 10"
    } else if (par_tmp[[session$token]]$omic_type == "Metabolomics"){
      tmp_logMessage <- "Remove anything which has a row median of 0"
    } else {
      tmp_logMessage <- "none"
    }
    fun_LogIt("## Pre Processing {.tabset .tabset-fade}")
    fun_LogIt(message = "### Info")
    fun_LogIt(
      message = "**PreProcessing** - Alaways done: removal of all entities which are constant over all samples"
    )
    fun_LogIt(
      message = paste0("**PreProcessing** - Preprocessing procedure -standard (depending only on omics-type): ",tmp_logMessage)
    )
    fun_LogIt(
      message = paste0(
        "**PreProcessing** - Preprocessing procedure -specific (user-chosen): ",
        ifelse(input$PreProcessing_Procedure == "vst_DESeq",
               paste0(
                 input$PreProcessing_Procedure,
                 " ~ ",paste(input$DESeq_formula_sub, collapse=" + ")),
               input$PreProcessing_Procedure)
      )
    )
    if(input$BatchEffect_Column != "NULL"){
      fun_LogIt(
        message = paste0(
          "**PreProcessing** - Batch Effect Correction: ",
          input$BatchEffect_Column
        )
      )
    }
    fun_LogIt(
      message = paste0(
        "**PreProcessing** - The resulting dimensions are: ",
        paste0(dim(res_tmp[[session$token]]$data),collapse = ", ")
      )
    )
    fun_LogIt(message = "### Publication Snippet")
    fun_LogIt(message = snippet_preprocessing(data=res_tmp[[session$token]],
                                              params=par_tmp[[session$token]]))
    fun_LogIt(message = "<br>")
  })

  # render plots and ui Parts
  output$violin_plot_color_ui <- renderUI({
    req(selectedData())
    selectInput(
      inputId = "violin_color",
      label = "Color the violin plot by:",
      choices = c(colnames(colData(res_tmp[[session$token]]$data_original))),
      selected = c(colnames(colData(res_tmp[[session$token]]$data_original)))[1],
      multiple = F
    )
  })
  output$debug <- renderText(dim(res_tmp[[session$token]]$data))

  ## Preprocessing save, Report and Code Snippet
  output$SavePlot_Preprocess <- downloadHandler(
    filename = function() {
      paste0("Preprocessing_ViolinPlot_", Sys.Date(), input$file_ext_Preprocess)
    },
    content = function(file) {
      # Create individual plots
      raw_plot <- violin_plot(
        res_tmp[[session$token]]$data_original[par_tmp[[session$token]][['entities_selected']], par_tmp[[session$token]][['samples_selected']]],
        violin_color = input$violin_color
      ) + ggtitle("Count distribution per sample - raw") + theme(legend.position = "none")

      preprocessed_plot <- violin_plot(
        res_tmp[[session$token]]$data,
        violin_color = input$violin_color
      ) + ggtitle("Count distribution per sample - preprocessed")

      # Arrange the plots side by side with more space for the right plot
      combined_plot <- grid.arrange(
        raw_plot,
        preprocessed_plot,
        ncol = 2,
        widths = c(1, 1.3)
      )

      # Save the combined plot
      ggsave(
        filename = file,
        plot = combined_plot,
        width = 16,  # Increase the width of the figure
        height = 8,  # Adjust height if necessary
        units = "in",
        device = gsub("\\.","",input$file_ext_Preprocess)
      )

      on.exit({
        file_path <- paste0("/www/",session$token,"/")
        tmp_filename <- paste0(
          getwd(),
          file_path,
          paste0(
            "Preprocessing_ViolinPlot_",
            format(Sys.time(), "%Y_%m_%d_%H_%M_%S"),
            input$file_ext_Preprocess
          )
        )
        raw_plot <- violin_plot(
          res_tmp[[session$token]]$data_original[par_tmp[[session$token]][['entities_selected']], par_tmp[[session$token]][['samples_selected']]],
          violin_color = input$violin_color
        ) + ggtitle("Count distribution per sample - raw") + theme(legend.position = "none")

        preprocessed_plot <- violin_plot(
          res_tmp[[session$token]]$data,
          violin_color = input$violin_color
        ) + ggtitle("Count distribution per sample - preprocessed")

        # Arrange the plots side by side with more space for the right plot
        combined_plot <- grid.arrange(
          raw_plot,
          preprocessed_plot,
          ncol = 2,
          widths = c(1, 1.3)
        )
        ggsave(
          filename = tmp_filename,
          plot = combined_plot,
          width = 16,  # Increase the width of the figure
          height = 8,  # Adjust height if necessary
          units = "in",
          device = gsub("\\.","",input$file_ext_Preprocess)
        )

        fun_LogIt(message = "## PreProcessing Violin Plot{.tabset .tabset-fade}")
        fun_LogIt(message = "### Info")
        fun_LogIt(message = paste0("**PreProcess** - The Samples were plotted after: ",input$violin_color))
        fun_LogIt(
          message = paste0("**PreProcess** - ![Violin Plot](",tmp_filename,")")
        )
        # no publication snippet as thats already in the log
      })
    }
  )

  observeEvent(input$only2Report_Preprocess,{
    notificationID <- showNotification("Saving...",duration = 0)
    tmp_filename <- paste0(
      getwd(),
      file_path,
      paste0(
        "Preprocessing_ViolinPlot_",
        format(Sys.time(), "%Y_%m_%d_%H_%M_%S"),
        input$file_ext_Preprocess
      )
    )
    raw_plot <- violin_plot(
      res_tmp[[session$token]]$data_original[par_tmp[[session$token]][['entities_selected']], par_tmp[[session$token]][['samples_selected']]],
      violin_color = input$violin_color
    ) + ggtitle("Count distribution per sample - raw") + theme(legend.position = "none")

    preprocessed_plot <- violin_plot(
      res_tmp[[session$token]]$data,
      violin_color = input$violin_color
    ) + ggtitle("Count distribution per sample - preprocessed")

    # Arrange the plots side by side with more space for the right plot
    combined_plot <- grid.arrange(
      raw_plot,
      preprocessed_plot,
      ncol = 2,
      widths = c(1, 1.3)
    )
    ggsave(
      filename = tmp_filename,
      plot = combined_plot,
      width = 16,  # Increase the width of the figure
      height = 8,  # Adjust height if necessary
      units = "in",
      device = gsub("\\.","",input$file_ext_Preprocess)
    )
    fun_LogIt(message = "## PreProcessing Violin Plot{.tabset .tabset-fade}")
    fun_LogIt(message = "### Info")
    fun_LogIt(message = paste0("**PreProcess** - The Samples were plotted after: ",input$violin_color))
    fun_LogIt(
      message = paste0("**PreProcess** - ![Violin Plot](",tmp_filename,")")
    )
    # no publication snippet as thats already in the log
    removeNotification(notificationID)
    showNotification("Saved!",type = "message", duration = 1)
  })

  output$getR_Code_Preprocess <- downloadHandler(
    filename = function() {
      paste0("ShinyOmics_Rcode2Reproduce_", Sys.Date(), ".zip")
    },
    content = function(file) {
      waiter <- Waiter$new(
        html = LOADING_SCREEN,
        color = "#3897F147",
        hide_on_render = FALSE
      )
      waiter$show()
      envList <- list(
        par_tmp = par_tmp[[session$token]]
      )
      temp_directory <- file.path(tempdir(), as.integer(Sys.time()))
      dir.create(temp_directory)
      # save csv files
      save_summarized_experiment(
        res_tmp[[session$token]]$data_original,
        temp_directory
      )

      write(
        create_workflow_script(
          pipeline_info = VIOLIN_PLOT_PIPELINE,
          par = par_tmp[[session$token]],
          path_to_util = file.path(temp_directory, "util.R")
        ),
        file.path(temp_directory, "Code.R")
      )

      saveRDS(envList, file.path(temp_directory, "Data.rds"))

      zip::zip(
        zipfile = file,
        files = dir(temp_directory),
        root = temp_directory
      )
      waiter$hide()
    },
    contentType = "application/zip"
  )

  # Sample Correlation ----
  # calling server without reactive it will be init upon start, with no update
  # of respective data inputs hence need of at least one reactive!
  sample_correlation_server(id = "sample_correlation")
  # significance analysis ----
  significance_analysis_server(id = 'SignificanceAnalysis')
  # PCA ----
  pca_Server(id = "PCA")
  # Heatmap ----
  heatmap_server(id = 'Heatmap')
  # Single Gene Visualisations ----
  single_gene_visualisation_server(id = 'single_gene_visualisation')

  # Enrichment Analysis ----
  enrichment_analysis_Server(
    id = 'EnrichmentAnalysis',
    data = res_tmp[[session$token]],
    params = par_tmp[[session$token]],
    reactive(updating$count)
  )
}
